“Pink Dream” by Vicky Silviana
颜色定义：
蓝色：程序ROM
黄色：微程序控制器
橙色：ALU
品红色：RAM
白色：程序计数器（PC/IP）
淡蓝色：调用栈
绿色：屏幕
粉红色：总线和控制线路

微程序引脚定义（从上到下）：
left:
bus_out
psw
reg_in
*
*
ir_in
p(2)(00=continue,10=enter,01=branch)

right:
imm_in
op(0=op1/dat,1=op2/addr)
r_out(0=hi,1=lo)
ram_write
pop
push
pc(2)(1=pc=imm,2=+1,3=pc=stack)

微程序：
read_instruction:
00 0000 0110 0000 0010
use_alu:
01 0000 0000 0000 0000
02 0000 0000 0110 0000
03 0110 0011 0000 0000
use_alu_imm:
04 0000 0000 0000 0000
05 0000 0000 1100 0000
06 0110 0011 0000 0000
jump:
07 0000 0001 0000 0000
08 0000 0011 0000 0001
write_mem:
09 0000 0000 0000 0000
0a 0000 0000 0110 0000
0b 0000 0011 0001 0000
write_bus:
0c 1000 0011 0000 0000
call:
0d 0000 0001 0000 0000
0e 0000 0011 0000 0101
return:
0f 0000 0000 0000 1000
10 0000 0011 0000 0011

标志：
0=OF
1=ZF
2=CF
3=SF

运算：
0000 SBC
0001 SUB
0010 ADD
0011 ADC
0100 AND
0101 NAND
0110 NOR
0111 OR
1000 XOR
1001 NXOR
1010 SHL
1011 SAR
1100 SHR
1101 RAM
111X IMM

指令定义：
AAA BBB CCC XXXX 000
A<-B(X)C
AAA BBB (210) XXXX 001
A<-B(X)I
AAA (543210) 111(6) 00(7)
A<-I
XXXXXXXX d CCRF 010
if(C) then PC=X
ddd AAA BBB dddd 011
[B]<-A
ddd AAA ddd dddd 100
bus out AAA
XXXXXXXX d CCRF 101
if(C) then call X
... 110
return

延迟（可能有误）：
*为决速步
PC->IR:13+2
IR->mAR:9
PSW->mAR:11*
mAR->OP:17*

ROM数据：
#0.入口
call ...
00 **** **** 0000 1101
jmp 01
01 0000 0001 0000 1010
#1.函数返回测试
sbc r0,r0,r0
02 0000 0000 0000 0000
ret
03 0000 0000 0000 0110
#2.Fibonacci数列
mov r1,1
04 0010 0000 1111 0000
mov r2,1
05 0100 0000 1111 0000
add r3,r1,r2
06 0110 0101 0001 0000
or r2,r1,r1
07 0100 0100 1011 1000
or r1,r3,r3
08 0010 1101 1011 1000
jnc 06
09 0000 0110 0101 0010
ret
0a 0000 0000 0000 0110
#2.内存测试(写入)
mov r1,3f
0b 0011 1111 1111 0000
sb r1,r1
0c 0000 0100 1000 0011
sub r1,r1,1
0d 0010 0100 1000 1001
jns 0c
0e 0000 1100 0111 0010
ret
0f 0000 0000 0000 0110
#3.内存测试(读取)
mov r1,3f
10 0011 1111 1111 0000
lb r2,r1
11 0100 0000 1110 1000
sub r0,r1,r2
12 0000 0101 0000 1000
jnz 16
13 0001 0110 0011 0010
sub r1,r1,1
14 0010 0100 1000 1001
jns 11
15 0001 0001 0111 0010
out r1
16 0000 0100 0000 0100
ret
17 0000 0000 0000 0110
#4.屏幕测试
mov r1,1
18 0010 0000 1111 0000
call 1d
19 0001 1101 0000 1101
mov r1,0
1a 0010 0000 0111 0000
call 1d
1b 0001 1101 0000 1101
ret
1c 0000 0000 0000 0110
#cls(r1)
shl r1,r1,7
1d 0010 0111 1101 0001
out r1
1e 0000 0100 0000 0100
add r1,r1,1
1f 0010 0100 1001 0001
shl r0,r1,1
20 0000 0100 1101 0001
jnz 1e
21 0001 1110 0011 0010
ret
22 0000 0000 0000 0110